package com.study.java.common;


/**
 * 1.封装。要用洗衣机只需要按一下开关就好了 没必要知道里面的复杂结构。该隐藏的隐藏 该暴露的暴露就是封装的思想
 * 2.高内聚，低耦合。
 * 3.封装的三个体现：①私有化属性 ②私有化方法（意义就是内部调用，不让外部调用）③单例模式
 * 4.权限修饰符修饰类的时候只能用public和缺省
 * 5.四个修饰符  自己 同包 不同包 同一工程    private  (default)  protected  public
 * 6. Person p=new Person(); Person()就是构造器
 * 7. 构造器：权限修饰符 类名（参数）{}--->①创建对象用的②初始化对象属性
 * 8.一旦自己定义了构造器，默认的无参构造器就不在了。但是我们可以自己再定义一个无参的构造器，哈哈~~~
 * 9. 赋值的位置：
    ① 默认初始化
    ② 显式初始化
    ③ 构造器中初始化
    ④ 通过“对象.属性“或“对象.方法”的方式赋值
    ⑤ 代码块
     赋值的先后顺序：① - ②/⑤ - ③ - ④  -->②和⑤是先写谁谁先赋值。但是我们一般先写②的方式
  10.this关键字 可以用来修饰属性/方法/构造器
        ①：修饰属性/方法 可以理解为 ""当前对象""  通过this.属性/this.方法来进行调用。但是通常情况下都省略了this. 只有在特殊情况下：
            形参和类的属性同名了 为了区分形参和属性采用this  >> this.name=name
        ②：调用构造器 this(形参列表);
            可以在类的构造器中使用"this(形参列表)"的方式，调用本类中重载的其他的构造器
            明确：构造器中不能通过"this(形参列表)"的方式调用自身构造器
            this(形参列表)"必须声明在类的构造器的首行！
            在类的一个构造器中，最多只能声明一个"this(形参列表)"
 11.package  -->小写 见名知意 .代表层级  通常使用所在公司域名的倒置： com.atguigu.xxx
 12.继承--->提升代码的复用性 降低编程成本。
    ①子类继承父类后将获得父类所有的属性和方法。包括父类私有的方法，只是因为封装性的影响，使得子类不能直接调用父类的私有结构而已
    ②子类可以增加自己个性化的属性和方法，实现个性化的拓展
    ③一个类可以被多个类继承，但是一个类只能继承一个类
    ④子父类是相对的概念--->连串继承 爷爷类 哈哈哈~~
    ⑤子类继承父类后就可以获得直接父类以及间接父类的属性和方法
    ⑥所有的类都直接或者间接的继承object类
 13.debug-->断点的意思是程序不是从上到下一直执行完毕，而是在断点处停止 类似于一个一个的小关卡
    ①F7:在Debug模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中
    ②F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内
    ③F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上
 14.方法的重写（继承范畴下的）（使用时直接粘贴复制）
      -->在子类中可以根据需要对从父类中继承来的方法进行改造，在程序执行时，子类的方法将覆盖父类的方法。
    ①子类重写的方法必须和父类被重写的方法具有相同的方法名称、 参数列表-->就是必须真的是针对同一个方法改造
    ②子类重写之后自己调用该方法的时候 调用的是自己重写后的方法 想用父类的方法可以用父类的对象去调或者super
    ③子类重写的方法的权限修饰符不能小于被重写的方法的权限修饰符-->煎饼果子-->相覆盖必须更大
        -->不能重写父类中的private方法
    ④如果父类被重写的方法返回值是void则重写后的方法也必须是void,如果父类被重写的方法返回值类型是A类型（引用类型）
    ，则子类重写的方法的返回值必须是A类型或者是A类的子类
    ⑤如果父类被重写的方法返回值类型是A类型（基本类型）则子类必须是A类型
    ⑥子类方法抛出的异常不能大于父类被重写方法的异常
    ⑦重写与被重写要么都是static要么都不是static
 15.super -->父类的  可以用来调用属性和方法和构造器  super.属性/super.方法/super(形参列表)
    ①我们在子类的方法或者构造器中调用父类的属性或者方法时，可以通过super.属性/super.方法 但是通常情况下就省略掉了
    ②特殊情况下不能省略：当父类的属性和子类的属性同名/当想调用父类被重写的方法时 必须用super加以区分
    ③super修饰构造器
       -->可以在子类的构造器中显示的使用super(形参列表)来调用指定的父类的构造器
       -->调用时必须在首行 必须和this二选一
       -->如果没有指定是用super修饰构造器还是用this修饰构造器默认的是用的super
 16.当我们通过子类的构造器new子类的对象时，都会调用其父类的构造器直至object，这也是为什么子类可以继承父类的属性和方法，但是
    new出来的对象实例是一个的
    如果一个子类继承了一个父类，父类具有参数构造函数，那么子类有责任将参数传递给父类，以便父类初始化



 */
public class StudyOOP_2 {


    public static void main(String[] args) {

        Animal a=new Animal();
        a.name="老虎";
        a.age=10;
        // legs怎么可能为-8呢？明显不符合常理 避免用户瞎操作。所以要对legs属性进行private，限制隐藏
        // 让用户不能通过对象.属性 瞎几把赋值. 但是又想给legs赋值 只不过不能允许瞎赋值，所以就额外提供set方法
        // 通过set方法可以对legs进行范围的控制同时可以让用户赋合理的值
        // 此外因为加了private使得legs 不能被获取 所以提供get方法以供获取属性

        //a.legs=-8;
        a.setLegs(-8);
        a.show();
    }

}
class  Animal{
    String name;
    int age;
    private int legs;

      // ①
//    public int setLegs(int legs){
//        this.legs=legs;
//        if(legs<=0){
//           return 0;
//        }else {
//            return legs;
//        }
//    }

     //  ②
//    public void setLegs(int l){
//        if(l<=0){
//            legs=1;
//        }else {
//            legs=l;
//        }
//    }

    // ③体会return 体会if else
    public void setLegs(int l){
        if(l<=0){
            return;  //这里的return表示退出结束方法，所以set失败 Legs为默认值
        }
        legs=l;
    }

    public int getLegs(){
        return legs;
    }

    public  void  show(){
        // 方法可以直接调用属性
        System.out.println("name is :"+name+",age is :"+age+",legs is "+legs);
    }
}